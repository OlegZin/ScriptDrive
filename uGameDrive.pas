unit uGameDrive;

interface

uses
    uScriptDrive, superobject, uConst,
    System.SysUtils, Generics.Collections, Classes, Math, StrUtils,
    uThinkMode, uGameInterface, uLog, uTower;

type

    TGameDrive = class
    private
        GameData: ISuperObject; /// все статичные данные игры.

        Target: string;  /// путь до текущего выбранного объекта в структуре GameState
            // текущая выбранная цель. используется для
            // методов, которые не применяются к конкретному объекту.
            // что позволит сократить набор методов для скриптов

    public

        constructor Create;
        destructor Destroy;

        function NewGame(level: integer; lang: string): string;
        function LoadGame( lang: string ): string; /// загрузка состояния игры
        function SaveGame: string;        /// сохранение текущего состояния игры
        procedure UpdateInterface;        /// перерисовка состояния интерфейса
        procedure SetMode(name: string);  /// переключение на окно указанного режима


/// ключевой метод
        procedure CheckStatus;             // проверка состояния игры и отработка событий

// работа с целями и их параметрами, инвентарем и прочим
        procedure SetPlayerAsTarget;   /// установка игрока целью методов работы с параметрами и прочего
        procedure SetCreatureAsTarget; /// установка монстра целью методов работы с параметрами и прочего

        procedure SetParam(name, value: string);    /// устанавливаем значение укакзанного параметра
        procedure ChangeParam(name, delta: string); /// изменене значения параметра на дельту
        function GetParam(name: string): string;    /// получение значение параметра

        procedure PlayEvent(name: string); /// выполнение скриптов цели, привязанных к указанному событию.
                                           /// например, "onAttack"

/// работа с языком
        function GetLang: string;          // возврат стрки с именем текущего языка ENG|RU
        procedure SetLang(lang: string);   // возврат стрки с именем текущего языка ENG|RU

/// работа с этажами
        procedure SetCurrFloor(val: string); // установить текущий этаж
        function GetCurrFloor: string;       // текущий этаж

        procedure SetCurrStep(val: string);  // устанвить текущий шаг
        function GetCurrStep: string;        // текущий шаг
        function GetMaxStep: string;         // максимальный шаг для текущего этажа

/// работа с предметами
        function GetRandItemName: string;          // внутреннее имя случайного предмета
        procedure ChangePlayerItemCount(name, delta: variant);

/// работа с ресурсами
        function GetRandResName: string;   // получение внутреннего имени случайного ресурса с учетом редкости

/// работа с целями на этажах.
/// при первом входе на целевой этаж срабатывает сюжетный скрипт.
        function GetCurrTarget: string;
        procedure SetNextTarget;

/// работа с логом
        procedure Log(kind, text: string);

/// работа с переменными
        procedure SetVar(name, value: string);
        function GetVar(name: string): string;

/// основные игровые методы
        procedure PlayerMakeAttack; /// выполняет цикл взаимной атаки игрока и текущего монстра в башне
                                    /// с отработкой событий и привязанных на них скриптов

{
        function GetArtLvl(name: string): string;  // возвращает уровень артефакта по его внутреннему имени
        procedure AllowMode(name: string);
        procedure AllowTool(name: string);
        procedure OpenThink(name: string);
}

    private
        Script : TScriptDrive;

        procedure InitItemsCraftCost; /// генерация стоимости предметов в ресурсах. стоимость будет различной в каждой игре, сохраняя интригу
        procedure InitFloorObjects;   /// генерация предметов на этажах
        function GetRandObjName: string; /// случайный объект, который может находиться на этаже, с учетом редкости и доступного количества
        function NeedExp(lvl: variant): string;

        function GetInLang(text: string; lang: string = ''): string;
    end;

Var
    GameDrive : TGameDrive;

implementation

{ TData }

{PUBLIC // Script allow}

procedure TGameDrive.CheckStatus;
/// пересчет игрового статуса исходя из текущего состояния игроовых объектов
begin
    /// проверяем достижение цели (целевого этажа). если так - выполняем скрипт
    if   'floor' + GameData.S['state.CurrFloor'] = GameData.S['state.CurrTarget']
    then Script.Exec(GameData.S['targetFloor.'+GameData.S['state.CurrTarget'] + '.script']);
end;


function TGameDrive.NewGame(level: integer; lang: string): string;
var
    i : integer;
    name: string;
begin
    result := '';
    InitItemsCraftCost;         // генерация рецептов предметов
    InitFloorObjects;           // генерация объектов на этажах

    GameData.S['state.Lang'] := lang;

    GameData.I['state.player.params.NeedExp'] := StrToInt(NeedExp(1));

    /// генерим первоначальные ресурсы, исходя из уровня игры
    /// автодействия
    GameData.I['state.player.params.AutoAction'] := 500 + 500 * level;

    /// генерим предметы
    for i := 1 to level do
    begin
        name := GetRandItemName;
        ChangePlayerItemCount(name, level);
    end;

    /// золото
    ChangePlayerItemCount('gold', 100000 + 10000 * level);

    /// проверяем состояние игровых объектов
    GameDrive.CheckStatus;

    GameDrive.UpdateInterface;
end;



function TGameDrive.SaveGame: string;
begin
    GameData.O['state'].SaveTo(
        DIR_DATA + FILE_GAME_DATA
//       ,false // не использовать красивое форматирование
//       ,false  // не преобразовывать русские буквы в эскейп последовательности
    );

    /// "красивая" версия для тестового контроля
    GameData.O['state'].SaveTo(
        DIR_DATA + FILE_GAME_DATA_TEST
       ,true // не использовать красивое форматирование
//       ,false  // не преобразовывать русские буквы в эскейп последовательности
    );
end;

function TGameDrive.LoadGame( lang: string ): string;
/// загрузка состояния игры
var
    state: ISuperObject;
begin
    /// подгрузка данных, если есть сохранение
    if DirectoryExists( DIR_DATA ) and FileExists( DIR_DATA + FILE_GAME_DATA ) then
    begin
        /// пытаемся загрузить
        state := TSuperObject.ParseFile( DIR_DATA + FILE_GAME_DATA, false );

        /// если данные корректны, объект существует
        if Assigned(state) then
        GameData.O['state'] := state;
    end;

    GameData.S['state.Lang'] := lang;

    /// проверяем состояние игровых объектов
    GameDrive.CheckStatus;

    GameDrive.UpdateInterface;
end;

procedure TGameDrive.Log(kind, text: string);
begin
    uLog.Log.Add(kind, text);
end;

function TGameDrive.GetLang: string;
begin
    result := GameData.S['state.Lang'];
end;

function TGameDrive.GetMaxStep: string;
begin
    result := IntToStr(GameData.I['state.CurrFloor'] * STEPS_BY_FLOOR);
end;

function TGameDrive.GetParam(name: string): string;
begin
    result := GameData.S[Target + 'params.' + name];
end;

procedure TGameDrive.SetLang(lang: string);
begin
    GameData.S['state.Lang'] := lang;
end;




procedure TGameDrive.SetMode(name: string);
begin
{    Tower.SetUnactive;
    Think.SetUnactive;

    if name = 'Tower' then Tower.SetActive;
    if name = 'Think' then Think.SetActive;
}
end;

procedure TGameDrive.SetNextTarget;
/// метод переключает текущую цель на следующий элемент массива targetFloor
begin
    GameData.S['state.CurrTargetFloor'] :=
        GameData.S['targetFloor.'+GameData.S['state.CurrTargetFloor']+'.next'];
end;

procedure TGameDrive.SetParam(name, value: string);
begin
    GameData.S[Target + 'params.' + name] := value;
end;

procedure TGameDrive.SetPlayerAsTarget;
begin
    Target := 'state.player.';
end;

procedure TGameDrive.SetVar(name, value: string);
begin
    GameData.S['state.vars.'+name] := value;
end;

procedure TGameDrive.UpdateInterface;
/// обновяем состояние окна активного режима
begin
    GameInterface.Update( GameData.O['state.player.params']);
//    fTower.Update( '{params:'+GameData.O['state.creature.params'].AsJSon+'},' );
    uLog.Log.Update;
end;


{ PRIVATE METHODS }



procedure TGameDrive.InitFloorObjects;
var
    floor, objCount, objCurr, index: integer;
    objName: string;
    obj: ISuperObject;
begin
    for floor := 1 to 20 do
    begin
        objCount := Max(Random(floor*10), 50);
        for objCurr := 1 to objCount do
        begin
            objName := GetRandObjName;  /// получаем допустимый объект

            index := floor * 1000 + objCurr; /// вычисляем уникальный индекс

            obj := SO();
            obj.S['name'] := objName;
            obj.S['params.HP'] := Script.Exec( GameData.S['floorObjects.'+objName+'.hpCalc'] );

        end;
    end;
end;

function TGameDrive.GetCurrFloor: string;
begin
    result := GameData.S['state.CurrFloor'];
end;

function TGameDrive.GetCurrStep: string;
begin
    result := GameData.S['state.CurrStep'];
end;

function TGameDrive.GetCurrTarget: string;
begin
    result := GameData.S['targetFloor.'+GameData.S['state.CurrTargetFloor']+'.floor'];
end;

procedure TGameDrive.SetCreatureAsTarget;
begin
    Target := 'state.creature.';
end;

procedure TGameDrive.SetCurrFloor(val: string);
begin
    GameData.S['state.CurrFloor'] := val;
end;



procedure TGameDrive.SetCurrStep(val: string);
begin
    GameData.S['state.CurrStep'] := val;
end;

function TGameDrive.GetInLang(text: string; lang: string = ''): string;
var
    multiLang: ISuperObject;
begin
    result := '';
    if lang = '' then lang := GetLang;

    multiLang := SO(text);
    if Assigned(multiLang) then result := multiLang[lang].AsString;
end;


function TGameDrive.GetRandObjName: string;
var
    val: integer;
    item: ISuperObject;
begin
    val := Random( GameData.I['objRaritySumm'] + 1);

    /// перебираем объекты, и учитываем только доступные по количеству
    for item in GameData.O['floorObjects'] do
    if item.I['allowCount'] <> 0 then
    begin
        val := val - item.I['rarity'];

        if val <= 0 then
        begin
            result := item.S['name'];
            item.I['allowCount'] := item.I['allowCount'] - 1; // списываем количество
            break;
        end;
    end;
end;

function TGameDrive.GetRandItemName: string;
var
    count: integer;
    item: ISuperObject;
begin
    count := Random( GameData.I['itemsCount'] );

    /// перебираем ресурсы и получаем один из них. с учетом редкости!
    for item in GameData.O['items'] do
    begin
        if count = 0 then
        begin
            result := item.S['name'];
            exit;
        end;
        Dec(count);
    end;
end;

function TGameDrive.GetRandResName: string;
var
    val: integer;
    item: ISuperObject;
begin
    /// получаем случайное число, указывающее на один из ресурсов
    val := Random( GameData.I['resRaritySumm'] + 1);

    /// перебираем ресурсы и получаем один из них. с учетом редкости!
    for item in GameData.O['resources'] do
    begin
        val := val - item.I['rarity'];
        if val <= 0 then
        begin
            result := item.S['name'];
            break;
        end;
    end;
end;

function TGameDrive.GetVar(name: string): string;
begin
    result := GameData.S['state.vars.'+name];
end;

procedure TGameDrive.InitItemsCraftCost;
/// генерим рецепты предметов. в каждой игре - разные
/// отталкиваемся от условной стоимости в ресурсах
var
    i
   ,cost     // условная остаточная стоимость предмета в ресурсах
   ,part     // условная суммарная стоимость текущего генерируемого компонента
   ,resCount // количество требуемого ресурса
            : integer;
    resName
            : string;
    item,   /// текущий рассматриваемый предмет
    craft   /// складывающаяся стоимость
            : ISuperObject;
begin

    for item in GameData.O['state.items'] do
    begin
        if item.I['cost'] = 0 then Continue;

        /// получаем общую стоимость
        cost := item.I['cost'];

        craft := SO();

        /// пока не распределна вся стоимость
        while cost > 0 do
        begin

            part := Random(item.I['cost']+1);  // получаем кусок, который нужно распределить

            part := Min(part, cost);           // выравниваемся, если выпало распределить больше остатка

            resName := GetRandResName;         // получаем случайный ресурс

            resCount := part div GameData.I['resources.'+resName+'.cost'];
                                               // выясняем сколько ресурса можно взять за остаток стоимости
            resCount := Max(1, resCount);      // если остатка не хватает, прописывает одну единицу

            /// добавляем ресурсы в рецепт
            if Assigned( craft[resName] )
            then craft.I[resName] := craft.I[resName] + resCount
            else craft.I[resName] := resCount;

            cost := cost - part;               // списываем израсходованную часть
        end;

        item.O['craft'] := craft;

    end;

end;


procedure TGameDrive.ChangeParam(name, delta: string);
begin
    GameData.D[Target + 'params.' + name] :=
        GameData.D[Target + 'params.' + name] + StrToFloatDef(delta, 0);
end;

procedure TGameDrive.ChangePlayerItemCount(name, delta: variant);
/// изменяем количество указанного предмета на указанную дельту (в + или - ),
/// но не ниже нуля.
begin
    GameData.I['state.items.'+name+'.count'] := Max(GameData.I['state.items.'+name+'.count'] + delta, 0);
end;


function TGameDrive.NeedExp(lvl: variant): string;
var
    prev, cost, buff, // переменные для вычисления стоимости
    i: integer;
begin

    prev := 0;
    cost := 10;

    /// получаем значение с нужным индексом в ряду фиббоначи - это стоимость левелапа
    for I := 0 to lvl do
    begin
        buff := cost;
        cost := cost + prev;
        prev := buff;
    end;

    result := IntToStr(cost);
end;


constructor TGameDrive.Create;
begin
   inherited;
   Script := TScriptDrive.Create;
end;

destructor TGameDrive.Destroy;
begin
    Script.Free;
    inherited;
end;

/// скриптовые команды

procedure TGameDrive.PlayerMakeAttack;
/// обработка взаимной атаки игрока и монстра в башне
/// алгоритм:
///     1. из текущих характеристик монстра и игрока инициализируются переменные боя:
///         mc_DMG - выкинутый монстром урон
///         mc_BLK - вычисленная величина блока урона от игрока
///         mc_GEM - количество полученных монстром кристаллов
///         pl_DMG - вычисленный урон игрока по монстру
///         pl_BLK - вычисленная величина блока урона от монстра
///         gm_RED - количество выпавших из монстра красных кристаллов
///         gm_WHT - количество выпавших из монстра белых кристаллов
///         gm_BLU - количество выпавших из монстра синих кристаллов
///         gm_GRN - количество выпавших из монстра зеленых кристаллов
///         gm_PRP - количество выпавших из монстра фиолетовых кристаллов
///         gm_YLW - количество выпавших из монстра желтых кристаллов
///     2. отыгрываются скрипты на событие onAttack у монстра и игрока, котрые могут модифицировать значения
///     3. определяется список изменяемых параметров игрока и монстра
///     4. на изменение каждого параметра игрока и монстра:
///           4.1 инициализируются переменные:
///               prm_Action - имя события в рамках которого изменилось. в данном случае "onAttack"
///                            может использоваться для отсечения изменений,
///                            например блочить урон от атаки, но получать от магии
///               prm_Name - имя изменяемого параметра, например HP
///               prm_Delta - целая/дробная величина изменеия, может быть как в плюс, так и в минус
///           4.2 отыгрывается событие onParamChange
///           4.3 параметр prm_Name модифицируется согласно текущему значению prm_Delta
///     5. вызывается метод проверки статуса игры.
///        например, игрок мог нанести смертельный урон монстру или погибнуть сам.
///     6. вызывается метод обновления интерфейса
var
    CreatureHP: integer;
    CreatureDEF: integer;
    PlayerATK: integer;
    DMG, BLOCK : integer;
    ATKbuff: integer;
    bustedBySword: integer;

    Player: ISuperObject;
    Creature: ISuperObject;
begin

    ///
end;



procedure TGameDrive.PlayEvent(name: string);
begin
///
end;

initialization
   GameDrive := TGameDrive.Create;
   GameDrive.GameData := SO(GAME_DATA);  // загрузка дефолтных данных

finalization
   GameDrive.Free;

{
function TData.GetTrashIDs: string;
var
   i: integer;
   keys: TArray<integer>;
begin
    keys := arrFloors[CurrLevel].Trash.Keys.ToArray;

    for I := 0 to High(keys) do
        result := result + IntToStr(keys[i]) + ',';
end;
}


end.
